#' Predict driver transcrition factors for scRNA-seq clusters
#'
#' Predict driver transcrition factors for scRNA-seq clusters based on TF ChIP-seq peaks from CistromeDB. To run this function, you must first install the rabit package (see from http://rabit.dfci.harvard.edu/). 
#'
#' @docType methods
#' @name RNAAnnotateTranscriptionFactor
#' @rdname RNAAnnotateTranscriptionFactor
#'
#' @param RNA Seurat object generated by \code{\link{RNARunSeurat}} function.
#' @param genes Data frame of differential expressed geness, generated by \code{\link{RNARunSeurat}} function.
#' @param project Output project name for the rabit analysis result. Default is the project name of the Seurat object.
#' @param rabit.path Path of the rabit annotation files. The rabit annoation for CistromeDB is available at https://github.com/liulab-dfci/MAESTRO.
#' Download and unzip the annotation, supply the path of the annotations to \code{rabit.path}.
#' @param organism Organism for the dataset. Only support "GRCh38" and "GRCm38". Default is "GRCh38".
#' @param top.tf Output the target genes for the top TFs. Default is 10.
#'
#' @author Dongqing Sun, Chenfei Wang
#'
#' @return A list of top enriched transcription factor family for each cluster. For each listed TF family,
#' TFs are ranked according to expression.
#'
#' @examples
#' data(pbmc.RNA)
#' data(human.immune.CIBERSORT)
#' pbmc.RNA.res <- RNARunSeurat(inputMat = pbmc.RNA, project = "PBMC.scRNA.Seurat", min.c = 10, min.g = 100, dims.use = 1:15)
#' pbmc.RNA.res$RNA <- RNAAnnotateCelltype(pbmc.RNA.res$RNA, pbmc.RNA.res$genes, human.immune.CIBERSORT, min.score = 0.05)
#' pbmc.tfs <- RNAAnnotateTranscriptionFactor(pbmc.RNA.res$RNA, pbmc.RNA.res$genes, project = "PBMC.scRNA.TF", rabit.path = "/homes/cwang/annotations/rabit")
#' pbmc.tfs
#'
#' @export

RNAAnnotateTranscriptionFactor <- function(RNA, genes, project, rabit.path, organism = "GRCh38", top.tf = 10)
{
  require(Seurat)
  require(MAGeCKFlute)
  if(organism == "GRCh38"){
    org = "hsa"
    data(human.tf.family)
    tf_family_list <- HUMAN.TFFamily}
  if(organism == "GRCm38"){
    org = "mmu"
    data(mouse.tf.family)
    tf_family_list <- MOUSE.TFFamily}
  genes$entrezid = TransGeneID(genes$gene, fromType = "Symbol", toType = "Entrez",
                               organism = org, useBiomart = FALSE,
                               ensemblHost = "www.ensembl.org")
  genes = na.omit(genes)
  cluster_markers_list <- split(genes, genes$cluster)
  
  outputDir <- paste0(project, ".RABIT")
  if (!file.exists(outputDir)) dir.create(path=outputDir)  
  for(i in names(cluster_markers_list)){    
    cluster_marker_logfc <- cluster_markers_list[[i]][,c(2,8)]
    row.names(cluster_marker_logfc) <- cluster_marker_logfc[,'entrezid']
    cluster_marker_logfc <- data.frame(logfc = cluster_marker_logfc[,1], row.names = cluster_marker_logfc[,2])
    write.table(cluster_marker_logfc, paste0(project, ".RABIT/", i, ".txt"), sep = "\t", col.names = TRUE, row.names = TRUE, quote = FALSE)
  }
  
  message("Start to run Rabit.")
  for(i in names(cluster_markers_list)){
    system(paste0("Rabit -x ", rabit.path, "/interaction.Cistrome -y ", project, ".RABIT/", i,".txt -b ", rabit.path, "/interaction.Cistrome.background -o ", project, ".RABIT/", i, ".output"))
    message(paste0("Rabit in cluster ", i, " is done!"))
  }
  message("Rabit is done.")
  
  rabit_cluster_list <- list.files(paste0(project, ".RABIT"), pattern = "output.FDR")
  rabit_cluster_list <- unlist(strsplit(rabit_cluster_list, split = ".output.FDR"))

  notf_clusters = c()
  for(m in 1:length(rabit_cluster_list)){
    i <- rabit_cluster_list[m]
    out_fdr <- read.table(paste0(project, ".RABIT/",i,".output.FDR"),header = TRUE, row.names = 1, sep = "\t", check.names = FALSE)
    if(nrow(out_fdr) == 0){
      notf_clusters = c(notf_clusters, m)
      next()
    } else{
      out_fdr <- as.data.frame(t(out_fdr))
      out_fdr$gene <- unlist(strsplit(row.names(out_fdr), split = "@"))[seq(1,2*nrow(out_fdr),2)]
      out_fdr_max <- aggregate(logfc ~ gene, data = out_fdr, min)
      colnames(out_fdr_max)[2] <- i
      break()
    }
  }

  if(exists("out_fdr_max")){
    if(is.null(notf_clusters)){
      start_ind = 2
    }else if(notf_clusters[length(notf_clusters)] + 1 <= length(rabit_cluster_list)){
      start_ind = notf_clusters[length(notf_clusters)] + 1
    }
    for(m in start_ind:length(rabit_cluster_list)){
      i = rabit_cluster_list[m]
      out_fdr_cur <- read.table(paste0(project, ".RABIT/", i, ".output.FDR"), header = TRUE, row.names = 1, sep = "\t", check.names = FALSE)
      if(nrow(out_fdr_cur) == 0){
        notf_clusters = c(notf_clusters, m)
        next()
      }else{
        out_fdr_cur <- as.data.frame(t(out_fdr_cur))
        out_fdr_cur$gene <- unlist(strsplit(row.names(out_fdr_cur), split = "@"))[seq(1,2*nrow(out_fdr_cur),2)]
        out_fdr_max_cur <- aggregate(logfc ~ gene, data = out_fdr_cur, min)
        colnames(out_fdr_max_cur)[2] <- i
        out_fdr_max <- merge(out_fdr_max,out_fdr_max_cur)
      }
    }
    if(!is.null(notf_clusters)){
      message(paste0("There are no significant TFs identified in Cluster ",paste(rabit_cluster_list[notf_clusters], collapse = ", "),"."))
    }
    
    out_fdr_max$gene <- unlist(strsplit(out_fdr_max$gene, split = "\\."))[seq(2,2*nrow(out_fdr_max),2)]
    rownames(out_fdr_max) <- out_fdr_max$gene
    if(ncol(out_fdr_max) > 2){
      out_fdr_max <- out_fdr_max[,-1]
      out_fdr_max_log <- -log10(out_fdr_max)
    }else if(ncol(out_fdr_max) == 2){
      tf_cluster = colnames(out_fdr_max)[2]
      out_fdr_max <- data.frame(cluster = out_fdr_max[,2], row.names = out_fdr_max[,1])
      colnames(out_fdr_max) = tf_cluster
      out_fdr_max_log <- -log10(out_fdr_max)
    }

    cluster_drivertf_list <- lapply(colnames(out_fdr_max_log), function(x){
      return(data.frame(row.names = rownames(out_fdr_max_log)[order(out_fdr_max_log[,x],decreasing=T)], factor = rownames(out_fdr_max_log)[order(out_fdr_max_log[,x],decreasing=T)], score = sort(out_fdr_max_log[,x],decreasing=T), stringsAsFactors = FALSE))
    })
    names(cluster_drivertf_list) <- colnames(out_fdr_max_log)

    cluster_cell_list <- split(names(Idents(RNA)), Idents(RNA))
    cluster_avg_expr <- sapply(names(cluster_cell_list), function(x){
      return(apply(GetAssayData(object = RNA)[, cluster_cell_list[[x]]], 1, mean))
    })

    cluster_tf_list_filter = sapply(names(cluster_drivertf_list), function(x){
      tf_family_filter = sapply(cluster_drivertf_list[[x]][,1], function(y){
        if(y %in% names(tf_family_list) & length(intersect(tf_family_list[[y]], rownames(cluster_avg_expr))) > 1){
          tf_family_expr = cluster_avg_expr[intersect(tf_family_list[[y]], rownames(cluster_avg_expr)),x]
          tf_family_expr = tf_family_expr[which(tf_family_expr != 0.00)]
          tf_family = names(tf_family_expr)[order(tf_family_expr, decreasing=T)]
          return(list(tf_family,cluster_drivertf_list[[x]][y,2]))
        }else{
          if(!(y %in% rownames(cluster_avg_expr)) || cluster_avg_expr[y,x] == 0.00){
            return(NULL)
          }else{
            return(list(y,cluster_drivertf_list[[x]][y,2]))
          }
        }
      })
      tf_family_filter = tf_family_filter[-which(sapply(tf_family_filter,is.null))]
      tf_family_filter_tf = sapply(tf_family_filter,function(xx){
        return(xx[[1]])
      })
      tf_family_filter_score = unlist(sapply(tf_family_filter,function(xx){
        return(xx[[2]])
      }))

      tf_family_filter_dedup_tf = tf_family_filter_tf[!duplicated(tf_family_filter_tf)]
      tf_family_filter_dedup_score = tf_family_filter_score[!duplicated(tf_family_filter_tf)]
      listlen = sapply(tf_family_filter_dedup_tf, function(xx){
        length(xx)
      })

      tf_family_filter_desubset_tf = sapply(tf_family_filter_dedup_tf,function(xx){
        ifsubset = sapply(tf_family_filter_dedup_tf, function(yy){
          all(xx %in% yy)
        })
        return(tf_family_filter_dedup_tf[ifsubset][[which.max(listlen[ifsubset])]])
      })
      tf_family_filter_desubset_score = sapply(tf_family_filter_dedup_tf,function(xx){
        ifsubset = sapply(tf_family_filter_dedup_tf, function(yy){
          all(xx %in% yy)
        })
        return(max(tf_family_filter_dedup_score[ifsubset]))
      })

      tf_family_filter_desubset_dedup_tf = tf_family_filter_desubset_tf[!duplicated(tf_family_filter_desubset_tf)]
      tf_family_filter_desubset_dedup_score = tf_family_filter_desubset_score[!duplicated(tf_family_filter_desubset_tf)]
      tf_family_filter_desubset_dedup_tf_str = lapply(tf_family_filter_desubset_dedup_tf, function(xx){
        return(paste(xx, collapse = " | "))
      })
      return(list(tf = unlist(tf_family_filter_desubset_dedup_tf_str)[1:top.tf], score = tf_family_filter_desubset_dedup_score[1:top.tf]))
    })

    cluster_tf_list_filter_tf = cluster_tf_list_filter["tf",]
    cluster_tf_list_filter_score = cluster_tf_list_filter["score",]
    cluster_tf_df = reshape2::melt(cluster_tf_list_filter_tf)[,c(2,1)]
    colnames(cluster_tf_df) = c("Cluster","TF")
    cluster_score_df = reshape2::melt(cluster_tf_list_filter_score)[,c(2,1)]
    colnames(cluster_score_df) = c("Cluster","log(Rabitscore)")
    cluster_tf_df[,"log(Rabitscore)"] = round(cluster_score_df[, "log(Rabitscore)"], 2)

    reg_table <- data.frame(Cluster=Idents(RNA), CelltypeAnnotation=RNA@meta.data$assign.ident)
    row.names(reg_table) <- NULL
    reg_table_unique <- unique.data.frame(reg_table)

    reg_df <- merge(reg_table_unique, cluster_tf_df)
    write.table(reg_df,paste0(project, ".PredictedTFTop", top.tf, ".txt"), col.names = TRUE, row.names = FALSE, sep = "\t", quote = FALSE)
  
    tfList <- as.list(as.data.frame(cluster_tf_list_filter_tf, stringsAsFactors = FALSE))
    names(tfList) = names(cluster_tf_list_filter_tf)
  }else{
    message("There are no significant TFs for each cluster.")
    tfList <- NULL
  }

  return(tfList)
}

