#' Identify driver transcrition factors for scATAC-seq clusters
#'
#' Identify driver transcrition factors for scATAC-seq clusters based on TF ChIP-seq peaks from CistromeDB. To run this function, you must first install the giggle package (see from https://github.com/ryanlayer/giggle). 
#'
#' @docType methods
#' @name ATACAnnotateTranscriptionFactor
#' @rdname ATACAnnotateTranscriptionFactor
#' 
#' @param ATAC Seurat object of ATAC RPscore clustering  generated by \code{\link{ATACAnnotateCelltype}} function.
#' @param peaks Data frame of differential peaks, generated by \code{\link{ATACRunSeurat}} function.
#' @param project Output project name for the giggle analysis result. Default is the project name of the ATAC Seurat object
#' @param giggle.anno.path Path of the giggle annotation files. The giggle annoation for CistromeDB is available at https://github.com/liulab-dfci/MAESTRO.
#' Download and unzip the annotation, supply the path of the annotations to \code{giggle.anno.path}.
#' @param organism Organism for the dataset. Only support "GRCh38" and "GRCm38". Default is "GRCh38".
#' @param top.tf Output the target genes for the top TFs. Default is 10, only output the target genes for the top 10 TFs.
#'
#' @author Dongqing Sun, Changxin Wan, Chenfei Wang
#'
#' @return A list of top enriched transcription factors and their target genes for each cluster. 
#'
#'
#' @examples
#' data(pbmc.ATAC)
#' data(pbmc.RP)
#' data(human.immune.CIBERSORT)
#' pbmc.ATAC.res <- ATACRunSeurat(inputMat = pbmc.ATAC, project = "PBMC.scATAC.Seurat", method = "LSI")
#' pbmc.ATAC.res$ATAC <- ATACAnnotateCelltype(pbmc.ATAC.res$ATAC, pbmc.RP, human.immune.CIBERSORT, min.score = 0.1, genes.cutoff = 1E-3)
#' pbmc.tfs <- ATACAnnotateTranscriptionFactor(ATAC = pbmc.ATAC.res$ATAC, peaks = pbmc.ATAC.res$peaks, project = "PBMC.scATAC.TF", giggle.path = "/home/annotations/giggle")
#' pbmc.tfs
#'
#' @export

ATACAnnotateTranscriptionFactor <- function(ATAC, peaks, project = ATAC@project.name, giggle.path, organism = "GRCh38", top.tf = 10)
{
  require(Seurat)
  require(Matrix)
  if(organism == "GRCh38"){
      data(GRCh38.CistromeDB.genescore)
      data(human.tf.family)
      geneScore <- GRCh38.CistromeDB.genescore
      tf_family_list <- HUMAN.TFFamily}
  if(organism == "GRCm38"){
      data(GRCm38.CistromeDB.genescore)
      data(mouse.tf.family)
      geneScore <- GRCm38.CistromeDB.genescore
      tf_family_list <- MOUSE.TFFamily}

  if(nrow(peaks)==0){
    message("No differential peaks identified.")
    message("No driver TFs identified.")
    
    reg_table = data.frame(Cluster=Idents(ATAC), CelltypeAnnotation=ATAC@meta.data$assign.ident)
    row.names(reg_table) = NULL
    reg_table_unique = unique.data.frame(reg_table)
    reg_df = reg_table_unique
    reg_df$TF = "No TFs identified."
    write.table(reg_df,paste0(project, ".PredictedTFTop", top.tf, ".txt"), col.names = TRUE, row.names = FALSE, sep = "\t", quote = FALSE)
    
    return(list())
  }else{
    targetList <- list()
    tfList <- list()
    antFile <- read.csv(paste0(giggle.path,"/CistromeDB.sample.annotation.txt"), sep="\t", row.names=1, stringsAsFactors = FALSE)  
    outputDir <- paste0(project, ".GIGGLE")
    if (!file.exists(outputDir)) dir.create(path=outputDir)    
    for (icluster in unique(peaks$cluster)) {
      targetList[[icluster]] = list()
      ipeaks <- peaks[peaks$cluster == icluster, "gene"]
      ipeaks <- strsplit(ipeaks, "-")
      ipeaks <- data.frame(matrix(unlist(ipeaks), nrow=length(ipeaks), byrow=T))
      outputBed <- paste0(outputDir, "/", icluster, ".peaks.bed")
      write.table(ipeaks, outputBed, sep="\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
      
      message(paste("Identify enriched TFs for cluster ", icluster, "..."))
      cmd <- paste0("sort --buffer-size 2G -k1,1 -k2,2n -k3,3n ", outputBed, " | bgzip -c > ", outputBed, ".gz")
      system(cmd)
      cmd <- paste0("giggle search -i ", giggle.path, "/giggle.", organism, " -q ", outputBed, ".gz -s > ", outputBed, ".result.xls")
      system(cmd)
      resultDf <- read.table(paste0(outputBed, ".result.xls"), sep="\t", row.names=NULL, comment.char="", stringsAsFactors =  FALSE)
      resultDf <- resultDf[,-9]
      colnames(resultDf) <- c("file", "file_size", "overlaps", "odds_ratio", "fishers_two_tail", "fishers_left_tail", "fishers_right_tail", "combo_score")
      resultDf <- resultDf[resultDf$overlaps>0,]
      rownames(resultDf) <- sapply(strsplit(resultDf$file, "_1k/"), function(x) return(gsub("_5foldPeak.bed.gz", "", x[2])))
      resultDf <- resultDf[,c("file_size", "overlaps", "combo_score")]
      targetDf <- merge(resultDf, antFile, by.x=0, by.y=0)
      colnames(targetDf) <- c("sample_id", "sample_peak_number", "overlap_peak_number", "giggle_score", "species", "factor", "cell_line", "cell_type", "tissue", "disease")                          
      targetDf$biological_resource <- apply(targetDf, 1, function(x) return(paste0(x[7:10], collapse=";")))
      targetDf <- targetDf[, c("sample_id", "species", "factor", "biological_resource", "giggle_score", "sample_peak_number", "overlap_peak_number")]
      targetDf <- targetDf[order(-targetDf$giggle_score), ]
      targetDf <- targetDf[!duplicated(targetDf$factor), ]

      write.table(targetDf, paste0(outputBed, ".giggle.res.tfs.txt"), sep="\t", quote=FALSE, row.names=FALSE)
      if(nrow(targetDf) > 0){
        rownames(targetDf) = targetDf$factor
        tfList[[icluster]] <- targetDf[,c("factor","giggle_score")]
      }
      cmd <- paste0("rm ", outputBed, ".gz")
      system(cmd)
      cmd <- paste0("rm ", outputBed, ".result.xls")
      system(cmd)
    }
    message("Identification of enriched TFs is done.")
    
    cluster_cell_list = split(names(Idents(ATAC)), Idents(ATAC))
    cluster_avg_rp = sapply(names(cluster_cell_list), function(x){
      return(Matrix::rowMeans(GetAssayData(object = ATAC)[, cluster_cell_list[[x]]]))
    })
    
    cluster_tf_list_filter = sapply(names(tfList), function(x){
      tf_family_filter = sapply(tfList[[x]][,1], function(y){
        if(y %in% names(tf_family_list) & length(intersect(tf_family_list[[y]], rownames(cluster_avg_rp))) > 1){
          tf_family_expr = cluster_avg_rp[intersect(tf_family_list[[y]], rownames(cluster_avg_rp)),x]
          tf_family_expr = tf_family_expr[which(tf_family_expr != 0.00)]
          tf_family = names(tf_family_expr)[order(tf_family_expr, decreasing=T)]
          return(list(tf_family,tfList[[x]][y,2]))
        }else{
          if(!(y %in% rownames(cluster_avg_rp)) || cluster_avg_rp[y,x] == 0.00){
            return(NULL)
          }else{
            return(list(y,tfList[[x]][y,2]))
          }
        }
      }, simplify = FALSE)
      if(length(which(sapply(tf_family_filter,is.null))) > 0){
        tf_family_filter = tf_family_filter[-which(sapply(tf_family_filter,is.null))]
      }
      tf_family_filter_tf = sapply(tf_family_filter,function(xx){
        return(xx[[1]])
      })
      tf_family_filter_score = unlist(sapply(tf_family_filter,function(xx){
        return(xx[[2]])
      }))

      tf_family_filter_dedup_tf = tf_family_filter_tf[!duplicated(tf_family_filter_tf)]
      tf_family_filter_dedup_score = tf_family_filter_score[!duplicated(tf_family_filter_tf)]
      listlen = sapply(tf_family_filter_dedup_tf, function(xx){
        length(xx)
      })

      tf_family_filter_desubset_tf = sapply(tf_family_filter_dedup_tf,function(xx){
        ifsubset = sapply(tf_family_filter_dedup_tf, function(yy){
          all(xx %in% yy)
        })
        return(tf_family_filter_dedup_tf[ifsubset][[which.max(listlen[ifsubset])]])
      })
      tf_family_filter_desubset_score = sapply(tf_family_filter_dedup_tf,function(xx){
        ifsubset = sapply(tf_family_filter_dedup_tf, function(yy){
          all(xx %in% yy)
        })
        return(max(tf_family_filter_dedup_score[ifsubset]))
      })

      tf_family_filter_desubset_dedup_tf = tf_family_filter_desubset_tf[!duplicated(tf_family_filter_desubset_tf)]
      tf_family_filter_desubset_dedup_score = tf_family_filter_desubset_score[!duplicated(tf_family_filter_desubset_tf)]
      tf_family_filter_desubset_dedup_tf_str = lapply(tf_family_filter_desubset_dedup_tf, function(xx){
        return(paste(xx, collapse = " | "))
      })
      return(list(tf = unlist(tf_family_filter_desubset_dedup_tf_str)[1:top.tf], score = tf_family_filter_desubset_dedup_score[1:top.tf]))
    })

    cluster_tf_list_filter_tf = cluster_tf_list_filter["tf",]
    cluster_tf_list_filter_score = cluster_tf_list_filter["score",]
    cluster_tf_df = reshape2::melt(cluster_tf_list_filter_tf)[,c(2,1)]
    colnames(cluster_tf_df) = c("Cluster","TF")
    cluster_score_df = reshape2::melt(cluster_tf_list_filter_score)[,c(2,1)]
    colnames(cluster_score_df) = c("Cluster","Gigglescore")
    cluster_tf_df[,"log(Gigglescore)"] = round(log10(cluster_score_df$Gigglescore), 2)
    
    reg_table = data.frame(Cluster=Idents(ATAC), CelltypeAnnotation=ATAC@meta.data$assign.ident)
    row.names(reg_table) = NULL
    reg_table_unique = unique.data.frame(reg_table)
    
    reg_df = merge(reg_table_unique, cluster_tf_df)
    write.table(reg_df,paste0(project, ".PredictedTFTop", top.tf, ".txt"), col.names = TRUE, row.names = FALSE, sep = "\t", quote = FALSE)
    
    for(icluster in colnames(cluster_tf_list_filter)){
      message(paste("Identify target genes for the top ", top.tf, " TFs for cluster ", icluster, "..."))
      targetDf <- read.table(paste0(project, ".GIGGLE/", icluster, ".peaks.bed.giggle.res.tfs.txt"), sep="\t", header = TRUE, stringsAsFactors = FALSE, quote = "")
      tfs = cluster_tf_list_filter_tf[[icluster]]
      tfs = sapply(tfs, function(x){
        tf = unlist(strsplit(x, split = " | ", fixed = TRUE))[1]
        return(tf)
      })
      names(tfs) = NULL
      for (tf in tfs) {
        if(tf %in% targetDf$factor){
          dcid <- as.character(targetDf[targetDf$factor==tf, "sample_id"])
          tfTarget <- geneScore[["genes"]][geneScore[["indices"]][[dcid]]]
          write.table(data.frame(tfTarget), paste0(project, ".GIGGLE/", icluster, ".", tf, ".", dcid, ".target.genes.top500.txt"), sep="\t", quote=FALSE, row.names=FALSE, col.names=FALSE)
        }
      }
    }
    tfListExpand = as.list(as.data.frame(cluster_tf_list_filter_tf, stringsAsFactors = FALSE))
    names(tfListExpand) = names(cluster_tf_list_filter_tf)
    return(tfListExpand)
  }
}

